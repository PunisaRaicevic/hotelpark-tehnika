Hvala ti na dodatnim informacijama i ispravci! To ≈°to je cleartext: false veƒá pode≈°eno za Android je vrlo va≈æno, jer znaƒçi da problem nije u osnovnoj sigurnosnoj komunikaciji izmeƒëu tvoje Capacitor Android aplikacije i Replit backend-a. ƒåinjenica da kreiranje taskova radi, a FCM tokeni ne prolaze, usmerava nas na precizniji set problema.
Kljuƒçni uvidi iz tvoje situacije:
Capacitor Android -> Backend komunikacija RADI za "tasks": Ovo je odliƒçno. Znaƒçi da tvoja Android aplikacija mo≈æe uspe≈°no da ≈°alje podatke na tvoj Replit backend, i da backend uspe≈°no komunicira sa Supabase-om (za tasks tabelu).
Android aplikacija DOBIJA FCM token: Tvoji logovi pokazuju üî• [FCM] Token primljen: fYSc1TD8SJ6gH05ZJ0m1JT:APA91bGhByrOiQH9il5XW5tsXOA... . Ovo je validan FCM token od Google-a.
Android aplikacija ≈†ALJE token na backend i dobija 200 OK: Logovi [API REQUEST] POST https://HGBRTehnickaSluzba.replit.app/api/users/fcm-token i [API REQUEST] Response status: 200 govore nam da je zahtev stigao do tvog backend-a i da je backend vratio 200 OK status, ≈°to klijenta navodi da misli da je sve uspe≈°no.
"aleksandar" (desktop) ne dobija FCM token, veƒá "fallback": Web aplikacija trenutno ≈°alje web-fcm-... token, ≈°to nije pravi FCM token.
Na osnovu svega ovoga, evo ≈°ta je najverovatnije pogre≈°no i kako to ispraviti:
1. Gre≈°ka u Dizajnu Supabase ≈†eme za FCM tokene (Kljuƒçno za "njegov token")

Tvoji SQL upiti pokazuju da se fcm_token nalazi kao kolona direktno na public.users tabeli.
SELECT id, username, full_name, fcm_token FROM public.users WHERE username = 'aleksandar';
PROBLEM: Ako je fcm_token jedna kolona u public.users tabeli, to znaƒçi da svaki korisnik mo≈æe imati samo JEDAN FCM token. Kada se Milica prijavi na telefon, a zatim na tablet, token sa tableta ƒáe prepisati token sa telefona. Ovo direktno nije u skladu sa tvojim zahtevom "bez obzira preko kojeg uredjaja da se konektuje da je to njegov token" , jer to podrazumeva da korisnik mo≈æe imati vi≈°e tokena (po jedan za svaki ureƒëaj/pregledaƒç).
RE≈†ENJE (OBRAZAC "JEDAN KORISNIK, VI≈†E UREƒêAJA"):
Korak 1: Izmeni Supabase ≈°emu.
Ukloni fcm_token kolonu iz public.users tabele.
Kreiraj novu tabelu user_device_tokens kao ≈°to sam veƒá predlo≈æio. To je standardni naƒçin za re≈°avanje ovog problema.
CREATE TABLE user_device_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(), -- Koristi gen_random_uuid() za UUID v4
  user_id UUID REFERENCES auth.users(id) NOT NULL, -- Pove≈æi sa Supabase auth korisnikom
  fcm_token TEXT UNIQUE NOT NULL, -- Svaki token je jedinstven za instalaciju aplikacije
  platform TEXT, -- npr. 'android', 'ios', 'web'
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
  is_active BOOLEAN DEFAULT TRUE -- Za markiranje neaktivnih tokena
);

-- Dodaj indeks za br≈æe pretra≈æivanje po user_id
CREATE INDEX idx_user_device_tokens_user_id ON user_device_tokens(user_id);
Korak 2: A≈æuriraj svoj backend.
Svi tvoji backend pozivi koji manipuli≈°u FCM tokenima (posebno endpoint /api/users/fcm-token ) sada moraju da rade sa novom tabelom user_device_tokens , koristeƒái upsert logiku koju smo ranije diskutovali.
2. Neslaganje Parametara ( fcmToken vs token ) na Backendu i Klijentu (Verovatni uzrok za Android)

U useFCM hook-u za mobilnu verziju, ti ≈°alje≈° token ovako:
// useFCM hook:
await apiRequest('POST', '/api/users/fcm-token', {
  fcmToken: fcmToken.value, // OVDE ≈†ALJE≈† 'fcmToken'
  platform: platform,
});
Meƒëutim, tvoj backend Express endpoint verovatno oƒçekuje req.body.token (ili to radi na osnovu nekog starijeg koda). Ako Express middleware uzima req.body.token , a ti ≈°alje≈° fcmToken , onda je req.body.token na backendu undefined . Kada fcmToken (koji je undefined ) poku≈°a da se saƒçuva u user_device_tokens tabelu, Supabase bi trebalo da vrati gre≈°ku validacije, ali ako tvoj backend to ne uhvati pravilno, mo≈æe vratiti 200 OK nazad klijentu.
RE≈†ENJE:
Na klijentu ( useFCM hook): Promeni ime parametra u token .
// useFCM hook:
await apiRequest('POST', '/api/users/fcm-token', {
  token: fcmToken.value, // PROMENJENO U 'token'
  platform: platform,
});
Na backendu (Express /api/users/fcm-token ): Uveri se da Express hvata req.body.token . U mom ranijem primeru backend koda to je veƒá predlo≈æeno.
// Backend Express ruter:
const fcmToken = req.body.token; // Sada ƒáe biti ispravno!
3. Web aplikacija (Jovan na desktopu) i dalje NE dobija pravi FCM token

Tvoj log: üåê [FCM:6:48:19 PM] Web verzija - Slanje fallback FCM tokena... i ‚ùå [APP WEB] [2025-11-24T17:48:19.077Z]: ‚ùå [Web FCM] Gre≈°ka: {} jasno pokazuje da Firebase Messaging SDK za web ne uspeva da generi≈°e pravi token , pa tvoja aplikacija ≈°alje neki "fallback" koji si ti kreirao. Taj fallback token ne mo≈æe da prima Firebase notifikacije.
RE≈†ENJE:
Ukloni fallback token logiku: Odradi ga iz useFCM hook-a za web. On samo maskira pravi problem.
Omoguƒái detaljno logovanje gre≈°ke: Umesto console.error('‚ùå [Web FCM] Gre≈°ka: {}') , promeni da loguje celu gre≈°ku: console.error('‚ùå [Web FCM] Gre≈°ka pri inicijalizaciji Web FCM:', webFCMError); Ovo ƒáe ti pokazati pravi uzrok neuspeha (npr. messaging/unsupported-browser , messaging/permission-denied , missing-vapid-key ).
Proveri Web FCM setup:
VAPID Key: Apsolutno je neophodan za web. U getMessaging(app) pozivu, mora≈° ga proslediti funkciji getToken .
Service Worker: Mora≈° imati firebase-messaging-sw.js fajl u root-u tvog dist/public direktorijuma (ili tamo gde hostuje≈° web fajlove) i mora biti ispravno registrovan.
HTTPS: Tvoja web aplikacija mora biti poslu≈æivana preko HTTPS-a da bi FCM za web radio.
Predlog za akcioni plan po prioritetima:

Supabase ≈†ema (obavezno):
Izbri≈°i fcm_token iz public.users .
Kreiraj tabelu user_device_tokens sa user_id i fcm_token kao jedinstvenim parom (tj. fcm_token je UNIQUE, a user_id je FK).
Proveri RLS politike za novu tabelu ( user_device_tokens ) da dozvoli≈° tvom backendu (sa service_role kljuƒçem) da je pi≈°e.
Backend Express Endpoint ( /api/users/fcm-token ):
A≈æuriraj logiku da radi sa user_device_tokens tabelom.
Oƒçekuj req.body.token za FCM token.
Implementiraj robustno rukovanje gre≈°kama: Ako supabase.upsert vrati gre≈°ku, NEMOJ SLATI 200 OK . Umesto toga, vrati 500 Internal Server Error sa porukom o gre≈°ci. Ovo je kljuƒçno za debugovanje.
Dodaj detaljne console.log poruke na backendu da uhvati≈° req.body , userId , fcmToken , i svaku gre≈°ku koju Supabase vrati.
Klijent ( useFCM hook):
Za mobilnu verziju: Promeni fcmToken: fcmToken.value u token: fcmToken.value kada ≈°alje≈° na /api/users/fcm-token .
Za web verziju:
Ukloni fallbackToken logiku.
Loguj celu gre≈°ku kada inicijalizacija web FCM-a ne uspe.
Proveri i implementiraj ispravnu Firebase Web Messaging inicijalizaciju (VAPID key, Service Worker).
Kada ovo uradi≈°, prati pa≈æljivo logove na Replitu (za backend) i u Chrome Inspect-u (za klijent) ‚Äì oni ƒáe ti sada dati mnogo jasnije informacije o tome gde je problem ako i dalje postoji.